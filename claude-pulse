#!/usr/bin/env bash
set -euo pipefail

# Claude Pulse - Auto-trigger Claude Code to keep token quota fresh
# macOS only (requires launchd, pmset, caffeinate)

CONFIG_DIR="$HOME/.claude-pulse"
CONFIG_FILE="$CONFIG_DIR/config.json"
LOG_DIR="$CONFIG_DIR/logs"
TRIGGER_SCRIPT="$CONFIG_DIR/trigger.sh"
LAUNCH_AGENTS_DIR="$HOME/Library/LaunchAgents"
PLIST_PREFIX="com.claude-pulse"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
REV='\033[7m'
NC='\033[0m'

_cleanup_term() { tput cnorm 2>/dev/null || true; }
trap _cleanup_term EXIT INT TERM

info()    { echo -e "${BLUE}[info]${NC} $*"; }
success() { echo -e "${GREEN}[ok]${NC} $*"; }
warn()    { echo -e "${YELLOW}[warn]${NC} $*"; }
error()   { echo -e "${RED}[error]${NC} $*" >&2; }

# ── JSON helpers (python3) ──────────────────────────────────────────

json_get() {
    python3 -c "import json; print(json.load(open('$1')).get('$2',''))"
}

json_get_array() {
    python3 -c "import json; print(' '.join(json.load(open('$1')).get('$2',[])))"
}

json_set_bool() {
    python3 << PYEOF
import json
with open("$1") as f: d = json.load(f)
d["$2"] = $3
with open("$1", "w") as f: json.dump(d, f, indent=2); f.write("\n")
PYEOF
}

# ── Interactive UI components ───────────────────────────────────────

# Single-select menu.  Sets UI_MENU_RESULT (0-based index).
ui_menu() {
    local title="$1"; shift
    local -a opts=("$@")
    local cnt=${#opts[@]} sel=0
    local draw=$((cnt + 4))

    tput civis
    local first=true
    while true; do
        [[ "$first" == true ]] && first=false || printf "\033[%dA\r" "$draw"

        printf '\n'
        printf '  \033[1m%s\033[0m\n' "$title"
        printf '\n'
        for i in "${!opts[@]}"; do
            if [[ $i -eq $sel ]]; then
                printf '  \033[36m▸ %s\033[0m\033[K\n' "${opts[$i]}"
            else
                printf '    %s\033[K\n' "${opts[$i]}"
            fi
        done
        printf '\n'
        printf '  \033[2m↑↓ move  Enter select\033[0m\033[K'

        IFS= read -rsn1 key
        case "$key" in
            $'\e') read -rsn2 key
                case "$key" in
                    '[A') ((sel > 0)) && ((sel--)) || true ;;
                    '[B') ((sel < cnt-1)) && ((sel++)) || true ;;
                esac ;;
            '') break ;;
        esac
    done
    printf '\n'
    tput cnorm
    UI_MENU_RESULT=$sel
}

# Half-hour time grid with dynamic effective-window display.
# Usage: ui_time_grid multi|single [base_date] [preselected ...]
#   base_date: YYYY-MM-DD for one-time triggers, "" for recurring
# Sets UI_GRID_RESULT (space-separated HH:MM, or empty).
ui_time_grid() {
    local mode="$1"
    local base_date="${2:-}"
    shift 2 2>/dev/null || shift $#
    local -a presel=()
    (($# > 0)) && presel=("$@")

    # Build 24 half-hour slots only
    local -a slots=()
    for ((h=0; h<24; h++)); do
        slots+=("$(printf '%02d:30' "$h")")
    done

    local cols=6 rows=4 total=24

    # Selection state
    local -a sel=()
    for ((i=0; i<total; i++)); do sel+=(0); done

    # Apply pre-selections
    if ((${#presel[@]} > 0)); then
        for p in "${presel[@]}"; do
            [[ -z "$p" ]] && continue
            for ((i=0; i<total; i++)); do
                [[ "${slots[$i]}" == "$p" ]] && sel[$i]=1
            done
        done
    fi

    # Precompute date info (avoid calling date on every keystroke)
    local -a _cn=("日" "一" "二" "三" "四" "五" "六")
    local -a _en=("Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat")
    local s_dow="" s_label="" e_dow="" e_label=""
    if [[ -n "$base_date" ]]; then
        local _di
        _di=$(python3 -c "
from datetime import datetime, timedelta
d = datetime.strptime('$base_date', '%Y-%m-%d')
nd = d + timedelta(days=1)
print(d.strftime('%w'), d.strftime('%m/%d'), nd.strftime('%w'), nd.strftime('%m/%d'))
")
        s_dow=$(echo "$_di" | cut -d' ' -f1)
        s_label=$(echo "$_di" | cut -d' ' -f2)
        e_dow=$(echo "$_di" | cut -d' ' -f3)
        e_label=$(echo "$_di" | cut -d' ' -f4)
    fi

    local cr=0 cc=0
    # draw: \n(1)+title\n(1)+\n(1) + rows×\n(4) + \n(1)+info\n(1) + \n(1)+hint(0) = rows+6
    local draw=$((rows + 6))

    tput civis
    local first=true
    while true; do
        [[ "$first" == true ]] && first=false || printf "\033[%dA\r" "$draw"

        printf '\n'
        if [[ "$mode" == "multi" ]]; then
            printf '  \033[1mSelect times\033[0m  \033[2mSpace toggle  Enter confirm  q back\033[0m\n'
        else
            printf '  \033[1mSelect time\033[0m  \033[2mEnter/Space select  q back\033[0m\n'
        fi
        printf '\n'

        for ((r=0; r<rows; r++)); do
            printf '  '
            for ((c=0; c<cols; c++)); do
                local idx=$((r * cols + c))
                local t="${slots[$idx]}"
                local on_cur=0
                [[ $r -eq $cr && $c -eq $cc ]] && on_cur=1

                if [[ $on_cur -eq 1 ]]; then
                    if [[ ${sel[$idx]} -eq 1 ]]; then
                        printf ' \033[7;32m %s \033[0m' "$t"
                    else
                        printf ' \033[7m %s \033[0m' "$t"
                    fi
                else
                    if [[ ${sel[$idx]} -eq 1 ]]; then
                        printf ' \033[32m[%s]\033[0m' "$t"
                    else
                        printf '  %s ' "$t"
                    fi
                fi
            done
            printf '\033[K\n'
        done

        # Dynamic effective-window info for cursor position
        local cur_idx=$((cr * cols + cc))
        local cur_slot="${slots[$cur_idx]}"
        local cur_h=${cur_slot%%:*}
        cur_h=$((10#$cur_h))
        local eff_end=$((cur_h + 5))
        local info=""

        if [[ -n "$base_date" ]]; then
            if ((eff_end >= 24)); then
                eff_end=$((eff_end - 24))
                info=$(printf "▶ %s → %s %s %s %02d:00 - %s %s %s %02d:00" \
                    "$cur_slot" \
                    "$s_label" "${_cn[$s_dow]}" "${_en[$s_dow]}" "$cur_h" \
                    "$e_label" "${_cn[$e_dow]}" "${_en[$e_dow]}" "$eff_end")
            else
                info=$(printf "▶ %s → %s %s %s %02d:00 - %02d:00" \
                    "$cur_slot" \
                    "$s_label" "${_cn[$s_dow]}" "${_en[$s_dow]}" "$cur_h" "$eff_end")
            fi
        else
            if ((eff_end >= 24)); then
                eff_end=$((eff_end - 24))
                info=$(printf "▶ %s → Daily %02d:00 - next day %02d:00" "$cur_slot" "$cur_h" "$eff_end")
            else
                info=$(printf "▶ %s → Daily %02d:00 - %02d:00" "$cur_slot" "$cur_h" "$eff_end")
            fi
        fi

        printf '\n'
        printf '  \033[33m%s\033[0m\033[K\n' "$info"
        printf '\n'
        printf '  \033[2m←→↑↓ navigate\033[0m\033[K'

        IFS= read -rsn1 key
        case "$key" in
            $'\e') read -rsn2 key
                case "$key" in
                    '[A') ((cr > 0)) && ((cr--)) || true ;;
                    '[B') ((cr < rows-1)) && ((cr++)) || true ;;
                    '[C') ((cc < cols-1)) && ((cc++)) || true ;;
                    '[D') ((cc > 0)) && ((cc--)) || true ;;
                esac ;;
            ' ')
                local idx=$((cr * cols + cc))
                if [[ "$mode" == "multi" ]]; then
                    sel[$idx]=$(( 1 - ${sel[$idx]} ))
                else
                    sel[$idx]=1; break
                fi ;;
            'q')
                UI_GRID_RESULT=""
                printf '\n'; tput cnorm; return ;;
            '')
                if [[ "$mode" == "single" ]]; then
                    local idx=$((cr * cols + cc))
                    sel[$idx]=1
                fi
                break ;;
        esac
    done
    printf '\n'
    tput cnorm

    UI_GRID_RESULT=""
    for ((i=0; i<total; i++)); do
        [[ ${sel[$i]} -eq 1 ]] && UI_GRID_RESULT+="${slots[$i]} "
    done
    UI_GRID_RESULT="${UI_GRID_RESULT% }"
}

# Date selector (next 14 days).  Sets UI_DATE_RESULT (YYYY-MM-DD or empty).
ui_date_selector() {
    local -a dates=() labels=()
    local -a cn_days=("日 Sun" "一 Mon" "二 Tue" "三 Wed" "四 Thu" "五 Fri" "六 Sat")
    for ((d=0; d<=14; d++)); do
        local ds dow
        ds=$(date -v+${d}d +%Y-%m-%d)
        dow=$(date -v+${d}d +%w)   # 0=Sunday
        dates+=("$ds")
        labels+=("$(date -v+${d}d +%m/%d)  ${cn_days[$dow]}")
    done

    local cnt=${#dates[@]} sel=0
    local draw=$((cnt + 4))

    tput civis
    local first=true
    while true; do
        [[ "$first" == true ]] && first=false || printf "\033[%dA\r" "$draw"

        printf '\n'
        printf '  \033[1mSelect date\033[0m  \033[2m↑↓ move  Enter select  q back\033[0m\n'
        printf '\n'
        for i in "${!labels[@]}"; do
            if [[ $i -eq $sel ]]; then
                printf '  \033[36m▸ %s\033[0m\033[K\n' "${labels[$i]}"
            else
                printf '    %s\033[K\n' "${labels[$i]}"
            fi
        done
        printf '\n'
        printf '\033[K'

        IFS= read -rsn1 key
        case "$key" in
            $'\e') read -rsn2 key
                case "$key" in
                    '[A') ((sel > 0)) && ((sel--)) || true ;;
                    '[B') ((sel < cnt-1)) && ((sel++)) || true ;;
                esac ;;
            'q') UI_DATE_RESULT=""; printf '\n'; tput cnorm; return ;;
            '') break ;;
        esac
    done
    printf '\n'
    tput cnorm
    UI_DATE_RESULT="${dates[$sel]}"
}

# ── Trigger script generation ───────────────────────────────────────

generate_trigger_script() {
    cat > "$TRIGGER_SCRIPT" << 'TRIGGEREOF'
#!/usr/bin/env bash
CONFIG_DIR="$HOME/.claude-pulse"
CONFIG_FILE="$CONFIG_DIR/config.json"
LOG_DIR="$CONFIG_DIR/logs"

log() {
    mkdir -p "$LOG_DIR"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_DIR/pulse-$(date +%Y-%m-%d).log"
}

log "Trigger started"

if [[ ! -f "$CONFIG_FILE" ]]; then
    log "ERROR: Config not found"; exit 1
fi

ENABLED=$(python3 -c "import json; print(json.load(open('$CONFIG_FILE')).get('enabled', False))")
if [[ "$ENABLED" != "True" ]]; then
    log "SKIP: Disabled"; exit 0
fi

CLAUDE_PATH=$(python3 -c "import json; print(json.load(open('$CONFIG_FILE'))['claude_path'])")
WORK_DIR=$(python3 -c "import json; print(json.load(open('$CONFIG_FILE'))['work_directory'])")

check_net() { host api.anthropic.com > /dev/null 2>&1; }
if ! check_net; then
    log "WARN: Network down, retry 30s"; sleep 30
    check_net || { log "ERROR: No network"; exit 1; }
fi

cd "$WORK_DIR" || { log "ERROR: cd $WORK_DIR failed"; exit 1; }

run_pulse() {
    local t0 t1 out ec
    t0=$(date +%s)
    out=$("$CLAUDE_PATH" -p "reply with only the word: pulse" --max-turns 1 2>&1) || true
    ec=$?
    t1=$(date +%s)
    if [[ $ec -eq 0 ]] && echo "$out" | grep -qi "pulse"; then
        log "SUCCESS: $((t1-t0))s"; return 0
    fi
    log "FAIL: exit=$ec dur=$((t1-t0))s out=$(echo "$out" | head -3 | tr '\n' ' ')"
    return 1
}

run_pulse || { log "WARN: Retry 30s"; sleep 30; run_pulse || log "ERROR: Both failed"; }

# Clean expired one-time triggers
python3 << 'PYEOF' 2>/dev/null || true
import json, os, subprocess
from datetime import date
cfg = os.path.expanduser("~/.claude-pulse/config.json")
la = os.path.expanduser("~/Library/LaunchAgents")
with open(cfg) as f: d = json.load(f)
today = date.today().isoformat()
keep, removed = [], []
for t in d.get("onetime_triggers", []):
    if t["date"] >= today: keep.append(t)
    else: removed.append(t)
if removed:
    d["onetime_triggers"] = keep
    with open(cfg, "w") as f: json.dump(d, f, indent=2); f.write("\n")
    for t in removed:
        ds = t["date"].replace("-", "")
        h, m = t["time"].split(":")
        label = f"com.claude-pulse.once.{ds}.{int(h):02d}{int(m):02d}"
        p = os.path.join(la, f"{label}.plist")
        subprocess.run(["launchctl", "unload", p], capture_output=True)
        try: os.remove(p)
        except: pass
PYEOF

# Clean old logs
find "$LOG_DIR" -name "pulse-*.log" -mtime +30 -delete 2>/dev/null || true
log "Trigger finished"
TRIGGEREOF
    chmod +x "$TRIGGER_SCRIPT"
}

# ── Plist generation ────────────────────────────────────────────────

_plist_body() {
    local label="$1" cal_interval="$2" claude_bin_dir="$3"
    cat << PEOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>${label}</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/bin/caffeinate</string>
        <string>-i</string>
        <string>${TRIGGER_SCRIPT}</string>
    </array>
    <key>StartCalendarInterval</key>
    ${cal_interval}
    <key>EnvironmentVariables</key>
    <dict>
        <key>PATH</key>
        <string>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:${claude_bin_dir}</string>
        <key>HOME</key>
        <string>${HOME}</string>
    </dict>
    <key>StandardOutPath</key>
    <string>${LOG_DIR}/launchd-${label}.log</string>
    <key>StandardErrorPath</key>
    <string>${LOG_DIR}/launchd-${label}.err</string>
</dict>
</plist>
PEOF
}

generate_recurring_plist() {
    local time_str="$1" claude_path="$2"
    local hour minute label pf

    hour=$(echo "$time_str" | cut -d: -f1 | sed 's/^0*//')
    minute=$(echo "$time_str" | cut -d: -f2 | sed 's/^0*//')
    [[ -z "$hour" ]] && hour=0
    [[ -z "$minute" ]] && minute=0

    label="${PLIST_PREFIX}.$(printf '%02d%02d' "$hour" "$minute")"
    pf="$LAUNCH_AGENTS_DIR/${label}.plist"

    local cal="<dict>
        <key>Hour</key>
        <integer>${hour}</integer>
        <key>Minute</key>
        <integer>${minute}</integer>
    </dict>"

    _plist_body "$label" "$cal" "$(dirname "$claude_path")" > "$pf"
    echo "$pf"
}

generate_onetime_plist() {
    local date_str="$1" time_str="$2" claude_path="$3"
    local month day hour minute label pf

    month=$(echo "$date_str" | cut -d- -f2 | sed 's/^0*//')
    day=$(echo "$date_str" | cut -d- -f3 | sed 's/^0*//')
    hour=$(echo "$time_str" | cut -d: -f1 | sed 's/^0*//')
    minute=$(echo "$time_str" | cut -d: -f2 | sed 's/^0*//')
    [[ -z "$month" ]] && month=1; [[ -z "$day" ]] && day=1
    [[ -z "$hour" ]] && hour=0;   [[ -z "$minute" ]] && minute=0

    local ds="${date_str//-/}"
    label="${PLIST_PREFIX}.once.${ds}.$(printf '%02d%02d' "$hour" "$minute")"
    pf="$LAUNCH_AGENTS_DIR/${label}.plist"

    local cal="<dict>
        <key>Month</key>
        <integer>${month}</integer>
        <key>Day</key>
        <integer>${day}</integer>
        <key>Hour</key>
        <integer>${hour}</integer>
        <key>Minute</key>
        <integer>${minute}</integer>
    </dict>"

    _plist_body "$label" "$cal" "$(dirname "$claude_path")" > "$pf"
    echo "$pf"
}

# ── Plist & pmset management ────────────────────────────────────────

unload_existing_plists() {
    for p in "$LAUNCH_AGENTS_DIR"/${PLIST_PREFIX}.*.plist; do
        [[ -f "$p" ]] || continue
        launchctl unload "$p" 2>/dev/null || true
        rm -f "$p"
    done
}

load_all_plists() {
    local c=0
    for p in "$LAUNCH_AGENTS_DIR"/${PLIST_PREFIX}.*.plist; do
        [[ -f "$p" ]] || continue
        launchctl load "$p" 2>/dev/null || warn "Failed: $(basename "$p")"
        c=$((c + 1))
    done
    echo "$c"
}

unload_all_plists() {
    local c=0
    for p in "$LAUNCH_AGENTS_DIR"/${PLIST_PREFIX}.*.plist; do
        [[ -f "$p" ]] || continue
        launchctl unload "$p" 2>/dev/null || true
        c=$((c + 1))
    done
    echo "$c"
}

setup_pmset_wake() {
    local earliest=""
    for t in "$@"; do
        local h
        h=$(echo "$t" | cut -d: -f1 | sed 's/^0*//')
        [[ -z "$h" ]] && h=0
        if ((h >= 0 && h <= 6)); then
            [[ -z "$earliest" || "$t" < "$earliest" ]] && earliest="$t"
        fi
    done

    [[ -z "$earliest" ]] && return 0

    local wh wm
    wh=$(echo "$earliest" | cut -d: -f1 | sed 's/^0*//')
    wm=$(echo "$earliest" | cut -d: -f2 | sed 's/^0*//')
    [[ -z "$wh" ]] && wh=0; [[ -z "$wm" ]] && wm=0
    wm=$((wm - 5))
    if ((wm < 0)); then
        wm=$((wm + 60)); wh=$((wh - 1))
        ((wh < 0)) && wh=23
    fi

    local wake_time
    wake_time=$(printf "%02d:%02d:00" "$wh" "$wm")
    info "Nighttime trigger ($earliest). Setting pmset wake at $wake_time"
    info "Requires sudo..."
    if sudo pmset repeat wakeorpoweron MTWRFSU "$wake_time"; then
        success "pmset wake set at $wake_time"
    else
        warn "Failed to set pmset wake"
    fi
}

# ── Commands ────────────────────────────────────────────────────────

cmd_setup() {
    echo ""
    echo -e "  ${BOLD}=== Claude Pulse Setup ===${NC}"
    echo ""

    # Auto-detect Claude CLI
    local claude_path="$HOME/.local/bin/claude"
    [[ -x "$claude_path" ]] || claude_path=$(command -v claude 2>/dev/null || true)
    if [[ -z "$claude_path" || ! -x "$claude_path" ]]; then
        error "Claude CLI not found. Install Claude Code first."
        exit 1
    fi
    local ver
    ver=$("$claude_path" --version 2>&1 | head -1) || true
    success "Found Claude CLI: $ver at $claude_path"

    # Collect triggers via interactive menu
    local -a rec_times=()
    local -a ot_triggers=()   # each element: "YYYY-MM-DD HH:MM"

    while true; do
        # Show current triggers
        if ((${#rec_times[@]} > 0 || ${#ot_triggers[@]} > 0)); then
            echo ""
            echo -e "  ${BLUE}Configured triggers:${NC}"
            ((${#rec_times[@]} > 0)) && echo -e "    Daily:    ${GREEN}${rec_times[*]}${NC}"
            if ((${#ot_triggers[@]} > 0)); then
                for ot in "${ot_triggers[@]}"; do
                    echo -e "    One-time: ${GREEN}${ot}${NC}"
                done
            fi
        fi

        ui_menu "What would you like to do?" \
            "Add recurring daily triggers" \
            "Add one-time trigger (specific date)" \
            "Clear all triggers" \
            "Apply and finish"

        case $UI_MENU_RESULT in
            0)  # Recurring
                if ((${#rec_times[@]} > 0)); then
                    ui_time_grid "multi" "" "${rec_times[@]}"
                else
                    ui_time_grid "multi" ""
                fi
                if [[ -n "$UI_GRID_RESULT" ]]; then
                    rec_times=($UI_GRID_RESULT)
                    success "Daily triggers: ${rec_times[*]}"
                fi
                ;;
            1)  # One-time
                ui_date_selector
                if [[ -n "$UI_DATE_RESULT" ]]; then
                    local chosen_date="$UI_DATE_RESULT"
                    ui_time_grid "single" "$chosen_date"
                    if [[ -n "$UI_GRID_RESULT" ]]; then
                        ot_triggers+=("$chosen_date $UI_GRID_RESULT")
                        success "Added: $chosen_date $UI_GRID_RESULT"
                    fi
                fi
                ;;
            2)  # Clear
                rec_times=()
                ot_triggers=()
                success "All triggers cleared"
                ;;
            3)  # Apply
                break
                ;;
        esac
    done

    if ((${#rec_times[@]} == 0 && ${#ot_triggers[@]} == 0)); then
        warn "No triggers configured."
        exit 0
    fi

    # Create directories
    mkdir -p "$CONFIG_DIR" "$LOG_DIR" "$LAUNCH_AGENTS_DIR"

    # Build JSON arrays
    local rec_json="[]"
    if ((${#rec_times[@]} > 0)); then
        rec_json=$(printf '"%s",' "${rec_times[@]}")
        rec_json="[${rec_json%,}]"
    fi

    local ot_json="["
    local ot_first=true
    if ((${#ot_triggers[@]} > 0)); then
        for ot in "${ot_triggers[@]}"; do
            local d="${ot%% *}" t="${ot##* }"
            [[ "$ot_first" == true ]] && ot_first=false || ot_json+=","
            ot_json+="{\"date\":\"$d\",\"time\":\"$t\"}"
        done
    fi
    ot_json+="]"

    # Write config
    python3 << PYEOF
import json
config = {
    "claude_path": "$claude_path",
    "work_directory": "$HOME",
    "enabled": True,
    "recurring_times": $rec_json,
    "onetime_triggers": $ot_json
}
with open("$CONFIG_FILE", "w") as f:
    json.dump(config, f, indent=2)
    f.write("\n")
PYEOF
    success "Config saved"

    # Generate trigger script
    generate_trigger_script
    success "Trigger script ready"

    # Remove old plists, generate new
    unload_existing_plists

    local -a plist_files=()
    if ((${#rec_times[@]} > 0)); then
        for t in "${rec_times[@]}"; do
            plist_files+=("$(generate_recurring_plist "$t" "$claude_path")")
        done
    fi
    if ((${#ot_triggers[@]} > 0)); then
        for ot in "${ot_triggers[@]}"; do
            local d="${ot%% *}" t="${ot##* }"
            plist_files+=("$(generate_onetime_plist "$d" "$t" "$claude_path")")
        done
    fi

    # pmset for nighttime triggers
    local -a all_times=()
    if ((${#rec_times[@]} > 0)); then
        all_times=("${rec_times[@]}")
    fi
    if ((${#ot_triggers[@]} > 0)); then
        for ot in "${ot_triggers[@]}"; do all_times+=("${ot##* }"); done
    fi
    ((${#all_times[@]} > 0)) && setup_pmset_wake "${all_times[@]}" || true

    # Load plists
    local loaded
    loaded=$(load_all_plists)
    success "Loaded $loaded agent(s)"

    # Verify
    echo ""
    bash -n "$TRIGGER_SCRIPT" 2>/dev/null && success "trigger.sh syntax OK" || warn "trigger.sh syntax error"
    if ((${#plist_files[@]} > 0)); then
        for pf in "${plist_files[@]}"; do
            plutil -lint "$pf" > /dev/null 2>&1 && \
                success "$(basename "$pf") valid" || \
                warn "$(basename "$pf") invalid"
        done
    fi

    echo ""
    success "Setup complete! Claude Pulse is active."
    echo ""
    echo "  claude-pulse status  — check state"
    echo "  claude-pulse logs    — view logs"
    echo ""
}

cmd_status() {
    echo ""
    echo -e "  ${BOLD}=== Claude Pulse Status ===${NC}"
    echo ""

    if [[ ! -f "$CONFIG_FILE" ]]; then
        warn "Not configured. Run 'claude-pulse setup'"
        exit 0
    fi

    local enabled claude_path rec_times
    enabled=$(json_get "$CONFIG_FILE" "enabled")
    claude_path=$(json_get "$CONFIG_FILE" "claude_path")
    rec_times=$(json_get_array "$CONFIG_FILE" "recurring_times")

    if [[ "$enabled" == "True" ]]; then
        echo -e "  Status:    ${GREEN}ENABLED${NC}"
    else
        echo -e "  Status:    ${RED}DISABLED${NC}"
    fi
    echo "  Claude:    $claude_path"
    [[ -n "$rec_times" ]] && echo "  Daily:     $rec_times"

    # One-time triggers
    local ot_info
    ot_info=$(python3 -c "
import json
d = json.load(open('$CONFIG_FILE'))
for t in d.get('onetime_triggers', []):
    print(f\"  One-time:  {t['date']} {t['time']}\")
" 2>/dev/null) || true
    [[ -n "$ot_info" ]] && echo "$ot_info"

    # Launch agents
    echo ""
    echo "  Launch Agents:"
    local has=false
    for p in "$LAUNCH_AGENTS_DIR"/${PLIST_PREFIX}.*.plist; do
        [[ -f "$p" ]] || continue
        has=true
        local label
        label=$(basename "$p" .plist)
        if launchctl list "$label" > /dev/null 2>&1; then
            echo -e "    ${GREEN}LOADED${NC}  $label"
        else
            echo -e "    ${YELLOW}IDLE${NC}    $label"
        fi
    done
    [[ "$has" == false ]] && echo "    (none)"

    # pmset
    echo ""
    echo "  pmset wake schedule:"
    local pmset_info
    pmset_info=$(pmset -g sched 2>/dev/null | grep -i "wake" || true)
    echo "    ${pmset_info:-(none)}"

    # Recent logs
    echo ""
    echo "  Recent logs:"
    local latest
    latest=$(ls -t "$LOG_DIR"/pulse-*.log 2>/dev/null | head -1)
    if [[ -n "$latest" ]]; then
        tail -5 "$latest" | while IFS= read -r line; do echo "    $line"; done
    else
        echo "    (none)"
    fi
    echo ""
}

cmd_start() {
    [[ -f "$CONFIG_FILE" ]] || { error "Run 'claude-pulse setup' first"; exit 1; }

    json_set_bool "$CONFIG_FILE" "enabled" "True"

    local loaded
    loaded=$(load_all_plists)
    ((loaded == 0)) && { warn "No agents. Run setup."; exit 1; }

    success "Started ($loaded agents)"

    # Re-apply pmset
    local rec_times
    rec_times=$(json_get_array "$CONFIG_FILE" "recurring_times")
    local -a arr=($rec_times)
    ((${#arr[@]} > 0)) && setup_pmset_wake "${arr[@]}" || true
}

cmd_stop() {
    [[ -f "$CONFIG_FILE" ]] || { error "Run 'claude-pulse setup' first"; exit 1; }

    json_set_bool "$CONFIG_FILE" "enabled" "False"

    local unloaded
    unloaded=$(unload_all_plists)

    success "Stopped ($unloaded agents)"
    warn "pmset wake still active. Cancel: sudo pmset repeat cancel"
}

cmd_logs() {
    local num=20 date_filter=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --today) date_filter=$(date +%Y-%m-%d); shift ;;
            --lines|-n) num="$2"; shift 2 ;;
            [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]) date_filter="$1"; shift ;;
            *) shift ;;
        esac
    done

    if [[ -n "$date_filter" ]]; then
        local f="$LOG_DIR/pulse-${date_filter}.log"
        [[ -f "$f" ]] && cat "$f" || info "No logs for $date_filter"
    else
        echo "=== Recent logs (last $num) ==="
        echo ""
        if ls "$LOG_DIR"/pulse-*.log > /dev/null 2>&1; then
            cat "$LOG_DIR"/pulse-*.log | sort | tail -"$num"
        else
            info "No logs yet"
        fi
    fi
}

cmd_help() {
    cat << 'EOF'
Claude Pulse - Auto-trigger Claude Code for token quota refresh

Usage: claude-pulse <command> [options]

Commands:
  setup     Interactive configuration (no typing required)
  start     Enable triggers
  stop      Disable triggers
  status    Show state
  logs      Show trigger logs
  help      This message

Log options:
  --today         Today's logs
  -n N            Last N entries (default 20)
  YYYY-MM-DD      Logs for date
EOF
}

# ── Main ────────────────────────────────────────────────────────────

case "${1:-help}" in
    setup)  cmd_setup ;;
    start)  cmd_start ;;
    stop)   cmd_stop ;;
    status) cmd_status ;;
    logs)   shift; cmd_logs "$@" ;;
    help|-h|--help) cmd_help ;;
    *)      error "Unknown: $1"; cmd_help; exit 1 ;;
esac
