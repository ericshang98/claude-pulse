#!/usr/bin/env bash
set -euo pipefail

# Claude Pulse - Auto-trigger Claude Code to keep token quota fresh
# macOS only (requires launchd, pmset, caffeinate)

CONFIG_DIR="$HOME/.claude-pulse"
CONFIG_FILE="$CONFIG_DIR/config.json"
LOG_DIR="$CONFIG_DIR/logs"
TRIGGER_SCRIPT="$CONFIG_DIR/trigger.sh"
LAUNCH_AGENTS_DIR="$HOME/Library/LaunchAgents"
PLIST_PREFIX="com.claude-pulse"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
REV='\033[7m'
NC='\033[0m'

_cleanup_term() { tput cnorm 2>/dev/null || true; }
trap _cleanup_term EXIT
trap 'echo ""; exit 130' INT TERM

info()    { echo -e "${BLUE}[info]${NC} $*"; }
success() { echo -e "${GREEN}[ok]${NC} $*"; }
warn()    { echo -e "${YELLOW}[warn]${NC} $*"; }
error()   { echo -e "${RED}[error]${NC} $*" >&2; }

# ── JSON helpers (python3) ──────────────────────────────────────────

json_get() {
    python3 -c "import json; print(json.load(open('$1')).get('$2',''))"
}

json_set_bool() {
    python3 << PYEOF
import json
with open("$1") as f: d = json.load(f)
d["$2"] = $3
with open("$1", "w") as f: json.dump(d, f, indent=2); f.write("\n")
PYEOF
}

# ── Config migration (v1 → v2) ─────────────────────────────────────

migrate_config_if_needed() {
    [[ -f "$CONFIG_FILE" ]] || return 0
    python3 << 'PYEOF'
import json, os, sys
cfg = os.path.expanduser("~/.claude-pulse/config.json")
with open(cfg) as f:
    d = json.load(f)
if "recurring_times" not in d:
    sys.exit(0)

recurring_triggers = []
for t in d.get("recurring_times", []):
    recurring_triggers.append({"time": t, "tasks": [{"mode": "pulse"}]})

onetime_triggers = []
for t in d.get("onetime_triggers", []):
    onetime_triggers.append({
        "date": t["date"],
        "time": t["time"],
        "tasks": [{"mode": "pulse"}]
    })

new_config = {
    "config_version": 2,
    "claude_path": d.get("claude_path", ""),
    "work_directory": d.get("work_directory", os.path.expanduser("~")),
    "enabled": d.get("enabled", True),
    "recurring_triggers": recurring_triggers,
    "onetime_triggers": onetime_triggers
}

with open(cfg, "w") as f:
    json.dump(new_config, f, indent=2)
    f.write("\n")
PYEOF
}

# ── Interactive UI components ───────────────────────────────────────

# Single-select menu.  Sets UI_MENU_RESULT (0-based index, or -1 if ESC/q).
ui_menu() {
    local title="$1"; shift
    local -a opts=("$@")
    local cnt=${#opts[@]} sel=0
    local draw=$((cnt + 4))

    tput civis
    local first=true
    while true; do
        [[ "$first" == true ]] && first=false || printf "\033[%dA\r" "$draw"

        printf '\n'
        printf '  \033[1m%s\033[0m\n' "$title"
        printf '\n'
        for i in "${!opts[@]}"; do
            if [[ $i -eq $sel ]]; then
                printf '  \033[36m▸ %s\033[0m\033[K\n' "${opts[$i]}"
            else
                printf '    %s\033[K\n' "${opts[$i]}"
            fi
        done
        printf '\n'
        printf '  \033[2m↑↓ move  Enter select  Esc/q back\033[0m\033[K'

        IFS= read -rsn1 key
        case "$key" in
            $'\e') read -rsn2 -t 1 key
                case "$key" in
                    '[A') ((sel > 0)) && ((sel--)) || true ;;
                    '[B') ((sel < cnt-1)) && ((sel++)) || true ;;
                    *)  # ESC alone
                        UI_MENU_RESULT=-1
                        printf '\n'; tput cnorm; return ;;
                esac ;;
            'q')
                UI_MENU_RESULT=-1
                printf '\n'; tput cnorm; return ;;
            '') break ;;
        esac
    done
    printf '\n'
    tput cnorm
    UI_MENU_RESULT=$sel
}

# Half-hour time grid with dynamic effective-window display.
# Usage: ui_time_grid multi|single [base_date] [preselected ...]
#   base_date: YYYY-MM-DD for one-time triggers, "" for recurring
# Sets UI_GRID_RESULT (space-separated HH:MM, or empty).
ui_time_grid() {
    local mode="$1"
    local base_date="${2:-}"
    shift 2 2>/dev/null || shift $#
    local -a presel=()
    (($# > 0)) && presel=("$@")

    # Build 24 half-hour slots only
    local -a slots=()
    for ((h=0; h<24; h++)); do
        slots+=("$(printf '%02d:30' "$h")")
    done

    local cols=6 rows=4 total=24

    # Selection state
    local -a sel=()
    for ((i=0; i<total; i++)); do sel+=(0); done

    # Apply pre-selections
    if ((${#presel[@]} > 0)); then
        for p in "${presel[@]}"; do
            [[ -z "$p" ]] && continue
            for ((i=0; i<total; i++)); do
                [[ "${slots[$i]}" == "$p" ]] && sel[$i]=1
            done
        done
    fi

    # Determine which slots are in the past (for today only)
    local now_hhmm=""
    local _is_today=false
    local _today_str
    _today_str=$(date +%Y-%m-%d)
    if [[ -z "$base_date" || "$base_date" == "$_today_str" ]]; then
        _is_today=true
        now_hhmm=$(date +%H:%M)
    fi

    # Precompute date info (avoid calling date on every keystroke)
    local -a _cn=("日" "一" "二" "三" "四" "五" "六")
    local -a _en=("Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat")
    local s_dow="" s_label="" e_dow="" e_label=""
    if [[ -n "$base_date" ]]; then
        local _di
        _di=$(python3 -c "
from datetime import datetime, timedelta
d = datetime.strptime('$base_date', '%Y-%m-%d')
nd = d + timedelta(days=1)
print(d.strftime('%w'), d.strftime('%m/%d'), nd.strftime('%w'), nd.strftime('%m/%d'))
")
        s_dow=$(echo "$_di" | cut -d' ' -f1)
        s_label=$(echo "$_di" | cut -d' ' -f2)
        e_dow=$(echo "$_di" | cut -d' ' -f3)
        e_label=$(echo "$_di" | cut -d' ' -f4)
    fi

    local cr=0 cc=0
    # draw: \n(1)+title\n(1)+\n(1) + rows×\n(4) + \n(1)+info\n(1) + \n(1)+hint(0) = rows+6
    local draw=$((rows + 6))

    tput civis
    local first=true
    while true; do
        [[ "$first" == true ]] && first=false || printf "\033[%dA\r" "$draw"

        printf '\n'
        if [[ "$mode" == "multi" ]]; then
            printf '  \033[1mSelect times\033[0m  \033[2mSpace toggle  Enter confirm  Esc/q back\033[0m\n'
        else
            printf '  \033[1mSelect time\033[0m  \033[2mEnter/Space select  Esc/q back\033[0m\n'
        fi
        printf '\n'

        for ((r=0; r<rows; r++)); do
            printf '  '
            for ((c=0; c<cols; c++)); do
                local idx=$((r * cols + c))
                local t="${slots[$idx]}"
                local on_cur=0
                [[ $r -eq $cr && $c -eq $cc ]] && on_cur=1

                # Past slot? (blue for times already passed today)
                local is_past=false
                if [[ "$_is_today" == true && -n "$now_hhmm" && "$t" < "$now_hhmm" ]]; then
                    is_past=true
                fi

                if [[ $on_cur -eq 1 ]]; then
                    if [[ ${sel[$idx]} -eq 1 ]]; then
                        printf ' \033[7;32m %s \033[0m' "$t"
                    else
                        printf ' \033[7m %s \033[0m' "$t"
                    fi
                else
                    if [[ ${sel[$idx]} -eq 1 ]]; then
                        printf ' \033[32m[%s]\033[0m' "$t"
                    elif [[ "$is_past" == true ]]; then
                        printf '  \033[34m%s\033[0m ' "$t"
                    else
                        printf '  %s ' "$t"
                    fi
                fi
            done
            printf '\033[K\n'
        done

        # Dynamic effective-window info for cursor position
        local cur_idx=$((cr * cols + cc))
        local cur_slot="${slots[$cur_idx]}"
        local cur_h=${cur_slot%%:*}
        cur_h=$((10#$cur_h))
        local eff_end=$((cur_h + 5))
        local info=""

        if [[ -n "$base_date" ]]; then
            if ((eff_end >= 24)); then
                eff_end=$((eff_end - 24))
                info=$(printf "▶ %s → %s %s %s %02d:00 - %s %s %s %02d:00" \
                    "$cur_slot" \
                    "$s_label" "${_cn[$s_dow]}" "${_en[$s_dow]}" "$cur_h" \
                    "$e_label" "${_cn[$e_dow]}" "${_en[$e_dow]}" "$eff_end")
            else
                info=$(printf "▶ %s → %s %s %s %02d:00 - %02d:00" \
                    "$cur_slot" \
                    "$s_label" "${_cn[$s_dow]}" "${_en[$s_dow]}" "$cur_h" "$eff_end")
            fi
        else
            if ((eff_end >= 24)); then
                eff_end=$((eff_end - 24))
                info=$(printf "▶ %s → Daily %02d:00 - next day %02d:00" "$cur_slot" "$cur_h" "$eff_end")
            else
                info=$(printf "▶ %s → Daily %02d:00 - %02d:00" "$cur_slot" "$cur_h" "$eff_end")
            fi
        fi

        printf '\n'
        printf '  \033[33m%s\033[0m\033[K\n' "$info"
        printf '\n'
        printf '  \033[2m←→↑↓ navigate  Esc/q back\033[0m\033[K'

        IFS= read -rsn1 key
        case "$key" in
            $'\e') read -rsn2 -t 1 key
                case "$key" in
                    '[A') ((cr > 0)) && ((cr--)) || true ;;
                    '[B') ((cr < rows-1)) && ((cr++)) || true ;;
                    '[C') ((cc < cols-1)) && ((cc++)) || true ;;
                    '[D') ((cc > 0)) && ((cc--)) || true ;;
                    *)  # ESC alone
                        UI_GRID_RESULT=""
                        printf '\n'; tput cnorm; return ;;
                esac ;;
            ' ')
                local idx=$((cr * cols + cc))
                if [[ "$mode" == "multi" ]]; then
                    sel[$idx]=$(( 1 - ${sel[$idx]} ))
                else
                    sel[$idx]=1; break
                fi ;;
            'q')
                UI_GRID_RESULT=""
                printf '\n'; tput cnorm; return ;;
            '')
                if [[ "$mode" == "single" ]]; then
                    local idx=$((cr * cols + cc))
                    sel[$idx]=1
                fi
                break ;;
        esac
    done
    printf '\n'
    tput cnorm

    UI_GRID_RESULT=""
    for ((i=0; i<total; i++)); do
        [[ ${sel[$i]} -eq 1 ]] && UI_GRID_RESULT+="${slots[$i]} "
    done
    UI_GRID_RESULT="${UI_GRID_RESULT% }"
}

# Date selector (next 14 days).  Sets UI_DATE_RESULT (YYYY-MM-DD or empty).
ui_date_selector() {
    local -a dates=() labels=()
    local today_str
    today_str=$(date +%Y-%m-%d)
    local -a cn_days=("日 Sun" "一 Mon" "二 Tue" "三 Wed" "四 Thu" "五 Fri" "六 Sat")
    for ((d=0; d<=14; d++)); do
        local ds dow
        ds=$(date -v+${d}d +%Y-%m-%d)
        dow=$(date -v+${d}d +%w)   # 0=Sunday
        dates+=("$ds")
        local lbl
        lbl="$(date -v+${d}d +%m/%d)  ${cn_days[$dow]}"
        [[ "$ds" == "$today_str" ]] && lbl+="  (today)"
        labels+=("$lbl")
    done

    local cnt=${#dates[@]} sel=0
    local draw=$((cnt + 4))

    tput civis
    local first=true
    while true; do
        [[ "$first" == true ]] && first=false || printf "\033[%dA\r" "$draw"

        printf '\n'
        printf '  \033[1mSelect date\033[0m  \033[2m↑↓ move  Enter select  Esc/q back\033[0m\n'
        printf '\n'
        for i in "${!labels[@]}"; do
            local _color=""
            [[ "${dates[$i]}" == "$today_str" ]] && _color="\033[32m"
            if [[ $i -eq $sel ]]; then
                printf '  \033[36m▸ %s\033[0m\033[K\n' "${labels[$i]}"
            elif [[ -n "$_color" ]]; then
                printf "  ${_color}  %s\033[0m\033[K\n" "${labels[$i]}"
            else
                printf '    %s\033[K\n' "${labels[$i]}"
            fi
        done
        printf '\n'
        printf '\033[K'

        IFS= read -rsn1 key
        case "$key" in
            $'\e') read -rsn2 -t 1 key
                case "$key" in
                    '[A') ((sel > 0)) && ((sel--)) || true ;;
                    '[B') ((sel < cnt-1)) && ((sel++)) || true ;;
                    *)  # ESC alone
                        UI_DATE_RESULT=""; printf '\n'; tput cnorm; return ;;
                esac ;;
            'q') UI_DATE_RESULT=""; printf '\n'; tput cnorm; return ;;
            '') break ;;
        esac
    done
    printf '\n'
    tput cnorm
    UI_DATE_RESULT="${dates[$sel]}"
}

# Configure tasks for a trigger time.
# Sets UI_TASKS_RESULT as a JSON array string.
ui_configure_tasks() {
    local time_str="$1"
    local tasks_json="[]"

    while true; do
        ui_menu "Task for $time_str:" \
            "Pulse (token refresh)" \
            "Custom prompt (Claude executes a task)"

        case $UI_MENU_RESULT in
            -1) # ESC/q — cancel, default to pulse
                if [[ "$tasks_json" == "[]" ]]; then
                    tasks_json='[{"mode":"pulse"}]'
                    info "Defaulting to pulse"
                fi
                break
                ;;
            0)  # Pulse
                tasks_json=$(echo "$tasks_json" | python3 -c "
import json, sys
tasks = json.load(sys.stdin)
tasks.append({'mode': 'pulse'})
print(json.dumps(tasks))
")
                success "Added pulse task"
                ;;
            1)  # Custom prompt
                tput cnorm
                echo ""
                echo -e "  ${BOLD}Enter prompt for Claude:${NC}"
                echo -n "  > "
                local prompt_text=""
                IFS= read -r prompt_text

                if [[ -z "$prompt_text" ]]; then
                    warn "Empty prompt, skipping"
                    continue
                fi

                # Max turns
                ui_menu "Max turns:" "5 (Recommended)" "1" "10" "20"
                local -a max_turns_map=(5 1 10 20)
                local max_turns=5
                if [[ $UI_MENU_RESULT -ge 0 ]]; then
                    max_turns=${max_turns_map[$UI_MENU_RESULT]}
                fi

                # Work directory
                ui_menu "Work directory:" "Default (~)" "Custom path"
                local work_dir=""
                if [[ $UI_MENU_RESULT -eq 1 ]]; then
                    tput cnorm
                    echo ""
                    echo -n "  Path: "
                    IFS= read -r work_dir
                fi

                # Build task JSON safely via env vars
                tasks_json=$(PROMPT_TEXT="$prompt_text" MAX_TURNS="$max_turns" WORK_DIR="$work_dir" TASKS="$tasks_json" python3 -c "
import json, os
tasks = json.loads(os.environ['TASKS'])
task = {'mode': 'prompt', 'prompt': os.environ['PROMPT_TEXT'], 'max_turns': int(os.environ['MAX_TURNS'])}
wd = os.environ['WORK_DIR']
if wd:
    task['work_directory'] = wd
tasks.append(task)
print(json.dumps(tasks))
")
                success "Added prompt task"
                ;;
        esac

        ui_menu "Add another task?" "No, done" "Yes, add another"
        [[ $UI_MENU_RESULT -ne 1 ]] && break
    done

    UI_TASKS_RESULT="$tasks_json"
}

# ── Trigger script generation ───────────────────────────────────────

generate_trigger_script() {
    cat > "$TRIGGER_SCRIPT" << 'TRIGGEREOF'
#!/usr/bin/env bash
CONFIG_DIR="$HOME/.claude-pulse"
CONFIG_FILE="$CONFIG_DIR/config.json"
LOG_DIR="$CONFIG_DIR/logs"

log() {
    mkdir -p "$LOG_DIR"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_DIR/pulse-$(date +%Y-%m-%d).log"
}

log "Trigger started (args: $*)"

if [[ ! -f "$CONFIG_FILE" ]]; then
    log "ERROR: Config not found"; exit 1
fi

ENABLED=$(python3 -c "import json; print(json.load(open('$CONFIG_FILE')).get('enabled', False))")
if [[ "$ENABLED" != "True" ]]; then
    log "SKIP: Disabled"; exit 0
fi

CLAUDE_PATH=$(python3 -c "import json; print(json.load(open('$CONFIG_FILE'))['claude_path'])")
DEFAULT_WORK_DIR=$(python3 -c "import json; print(json.load(open('$CONFIG_FILE'))['work_directory'])")

check_net() { host api.anthropic.com > /dev/null 2>&1; }
if ! check_net; then
    log "WARN: Network down, retry 30s"; sleep 30
    check_net || { log "ERROR: No network"; exit 1; }
fi

# Get tasks from config based on trigger arguments
TRIGGER_TYPE="${1:-}"
TRIGGER_TIME="${2:-}"
TRIGGER_DATE="${3:-}"

if [[ -z "$TRIGGER_TYPE" ]]; then
    # Backward compat: no args → single pulse
    TASKS_JSON='{"mode":"pulse"}'
else
    TASKS_JSON=$(TRIGGER_TYPE="$TRIGGER_TYPE" TRIGGER_TIME="$TRIGGER_TIME" TRIGGER_DATE="$TRIGGER_DATE" python3 -c "
import json, os, sys
cfg = os.path.expanduser('~/.claude-pulse/config.json')
with open(cfg) as f:
    d = json.load(f)

ttype = os.environ['TRIGGER_TYPE']
ttime = os.environ['TRIGGER_TIME']
tdate = os.environ.get('TRIGGER_DATE', '')
tasks = []
if ttype == 'recurring':
    for tr in d.get('recurring_triggers', []):
        if tr['time'] == ttime:
            tasks = tr.get('tasks', [{'mode': 'pulse'}])
            break
elif ttype == 'onetime':
    for tr in d.get('onetime_triggers', []):
        if tr['date'] == tdate and tr['time'] == ttime:
            tasks = tr.get('tasks', [{'mode': 'pulse'}])
            break

if not tasks:
    tasks = [{'mode': 'pulse'}]

for t in tasks:
    print(json.dumps(t))
") || { log "ERROR: Failed to read tasks from config"; TASKS_JSON='{"mode":"pulse"}'; }
fi

run_task() {
    local idx="$1" total="$2" task_json="$3"
    local mode
    mode=$(echo "$task_json" | python3 -c "import json,sys; print(json.load(sys.stdin).get('mode','pulse'))")

    local t0 t1 out ec
    t0=$(date +%s)

    if [[ "$mode" == "pulse" ]]; then
        cd "$DEFAULT_WORK_DIR" || { log "Task $idx/$total [pulse] FAIL: cd failed"; return 1; }
        out=$("$CLAUDE_PATH" -p "reply with only the word: pulse" --max-turns 1 2>&1) || true
        ec=$?
        t1=$(date +%s)
        if [[ $ec -eq 0 ]] && echo "$out" | grep -qi "pulse"; then
            log "Task $idx/$total [pulse] SUCCESS: $((t1-t0))s"
            return 0
        fi
        log "Task $idx/$total [pulse] FAIL: exit=$ec dur=$((t1-t0))s out=$(echo "$out" | head -3 | tr '\n' ' ')"
        # Retry for pulse tasks only
        log "Task $idx/$total [pulse] Retrying in 30s..."
        sleep 30
        t0=$(date +%s)
        out=$("$CLAUDE_PATH" -p "reply with only the word: pulse" --max-turns 1 2>&1) || true
        ec=$?
        t1=$(date +%s)
        if [[ $ec -eq 0 ]] && echo "$out" | grep -qi "pulse"; then
            log "Task $idx/$total [pulse] SUCCESS (retry): $((t1-t0))s"
            return 0
        fi
        log "Task $idx/$total [pulse] FAIL (retry): exit=$ec dur=$((t1-t0))s"
        return 1

    elif [[ "$mode" == "prompt" ]]; then
        local prompt max_turns work_dir
        prompt=$(echo "$task_json" | python3 -c "import json,sys; print(json.load(sys.stdin).get('prompt',''))")
        max_turns=$(echo "$task_json" | python3 -c "import json,sys; print(json.load(sys.stdin).get('max_turns',5))")
        work_dir=$(echo "$task_json" | python3 -c "import json,sys,os; print(os.path.expanduser(json.load(sys.stdin).get('work_directory','')))")
        [[ -z "$work_dir" ]] && work_dir="$DEFAULT_WORK_DIR"

        cd "$work_dir" || { log "Task $idx/$total [prompt] FAIL: cd $work_dir failed"; return 1; }

        # Pass prompt safely via env var
        out=$(CLAUDE_TASK_PROMPT="$prompt" "$CLAUDE_PATH" -p "$prompt" --max-turns "$max_turns" 2>&1) || true
        ec=$?
        t1=$(date +%s)

        local prompt_short="${prompt:0:50}"
        if [[ $ec -eq 0 ]]; then
            log "Task $idx/$total [prompt] SUCCESS: $((t1-t0))s \"$prompt_short\""
            return 0
        fi
        log "Task $idx/$total [prompt] FAIL: exit=$ec dur=$((t1-t0))s \"$prompt_short\""
        return 1

    else
        log "Task $idx/$total [unknown:$mode] SKIP"
        return 1
    fi
}

# Count tasks
task_count=0
while IFS= read -r _line; do
    [[ -n "$_line" ]] && ((task_count++)) || true
done <<< "$TASKS_JSON"
[[ $task_count -eq 0 ]] && task_count=1

# Execute tasks in parallel
pids=()
idx=0
while IFS= read -r task_json; do
    [[ -z "$task_json" ]] && continue
    ((idx++)) || true
    run_task "$idx" "$task_count" "$task_json" &
    pids+=($!)
done <<< "$TASKS_JSON"

failed=0
succeeded=0
if ((${#pids[@]} > 0)); then
    for pid in "${pids[@]}"; do
        wait "$pid" && ((succeeded++)) || ((failed++))
    done
fi

log "Trigger finished: $succeeded succeeded, $failed failed out of $task_count tasks"

# Clean expired one-time triggers
python3 << 'PYEOF' 2>/dev/null || true
import json, os, subprocess
from datetime import date
cfg = os.path.expanduser("~/.claude-pulse/config.json")
la = os.path.expanduser("~/Library/LaunchAgents")
with open(cfg) as f: d = json.load(f)
today = date.today().isoformat()
keep, removed = [], []
for t in d.get("onetime_triggers", []):
    if t["date"] >= today: keep.append(t)
    else: removed.append(t)
if removed:
    d["onetime_triggers"] = keep
    with open(cfg, "w") as f: json.dump(d, f, indent=2); f.write("\n")
    for t in removed:
        ds = t["date"].replace("-", "")
        h, m = t["time"].split(":")
        label = f"com.claude-pulse.once.{ds}.{int(h):02d}{int(m):02d}"
        p = os.path.join(la, f"{label}.plist")
        subprocess.run(["launchctl", "unload", p], capture_output=True)
        try: os.remove(p)
        except: pass
PYEOF

# Clean old logs
find "$LOG_DIR" -name "pulse-*.log" -mtime +30 -delete 2>/dev/null || true
TRIGGEREOF
    chmod +x "$TRIGGER_SCRIPT"
}

# ── Plist generation ────────────────────────────────────────────────

_plist_body() {
    local label="$1" cal_interval="$2" claude_bin_dir="$3"
    local trigger_type="${4:-}" trigger_time="${5:-}" trigger_date="${6:-}"

    # Build extra ProgramArguments for trigger.sh
    local extra_prog_args=""
    if [[ -n "$trigger_type" ]]; then
        extra_prog_args+=$'\n        <string>'"${trigger_type}"'</string>'
        extra_prog_args+=$'\n        <string>'"${trigger_time}"'</string>'
        [[ -n "$trigger_date" ]] && extra_prog_args+=$'\n        <string>'"${trigger_date}"'</string>'
    fi

    cat << PEOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>${label}</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/bin/caffeinate</string>
        <string>-i</string>
        <string>${TRIGGER_SCRIPT}</string>${extra_prog_args}
    </array>
    <key>StartCalendarInterval</key>
    ${cal_interval}
    <key>EnvironmentVariables</key>
    <dict>
        <key>PATH</key>
        <string>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:${claude_bin_dir}</string>
        <key>HOME</key>
        <string>${HOME}</string>
    </dict>
    <key>StandardOutPath</key>
    <string>${LOG_DIR}/launchd-${label}.log</string>
    <key>StandardErrorPath</key>
    <string>${LOG_DIR}/launchd-${label}.err</string>
</dict>
</plist>
PEOF
}

generate_recurring_plist() {
    local time_str="$1" claude_path="$2"
    local hour minute label pf

    hour=$(echo "$time_str" | cut -d: -f1 | sed 's/^0*//')
    minute=$(echo "$time_str" | cut -d: -f2 | sed 's/^0*//')
    [[ -z "$hour" ]] && hour=0
    [[ -z "$minute" ]] && minute=0

    label="${PLIST_PREFIX}.$(printf '%02d%02d' "$hour" "$minute")"
    pf="$LAUNCH_AGENTS_DIR/${label}.plist"

    local cal="<dict>
        <key>Hour</key>
        <integer>${hour}</integer>
        <key>Minute</key>
        <integer>${minute}</integer>
    </dict>"

    _plist_body "$label" "$cal" "$(dirname "$claude_path")" "recurring" "$time_str" > "$pf"
    echo "$pf"
}

generate_onetime_plist() {
    local date_str="$1" time_str="$2" claude_path="$3"
    local month day hour minute label pf

    month=$(echo "$date_str" | cut -d- -f2 | sed 's/^0*//')
    day=$(echo "$date_str" | cut -d- -f3 | sed 's/^0*//')
    hour=$(echo "$time_str" | cut -d: -f1 | sed 's/^0*//')
    minute=$(echo "$time_str" | cut -d: -f2 | sed 's/^0*//')
    [[ -z "$month" ]] && month=1; [[ -z "$day" ]] && day=1
    [[ -z "$hour" ]] && hour=0;   [[ -z "$minute" ]] && minute=0

    local ds="${date_str//-/}"
    label="${PLIST_PREFIX}.once.${ds}.$(printf '%02d%02d' "$hour" "$minute")"
    pf="$LAUNCH_AGENTS_DIR/${label}.plist"

    local cal="<dict>
        <key>Month</key>
        <integer>${month}</integer>
        <key>Day</key>
        <integer>${day}</integer>
        <key>Hour</key>
        <integer>${hour}</integer>
        <key>Minute</key>
        <integer>${minute}</integer>
    </dict>"

    _plist_body "$label" "$cal" "$(dirname "$claude_path")" "onetime" "$time_str" "$date_str" > "$pf"
    echo "$pf"
}

# ── Plist & pmset management ────────────────────────────────────────

unload_existing_plists() {
    for p in "$LAUNCH_AGENTS_DIR"/${PLIST_PREFIX}.*.plist; do
        [[ -f "$p" ]] || continue
        launchctl unload "$p" 2>/dev/null || true
        rm -f "$p"
    done
}

load_all_plists() {
    local c=0
    for p in "$LAUNCH_AGENTS_DIR"/${PLIST_PREFIX}.*.plist; do
        [[ -f "$p" ]] || continue
        launchctl load "$p" 2>/dev/null || warn "Failed: $(basename "$p")"
        c=$((c + 1))
    done
    echo "$c"
}

unload_all_plists() {
    local c=0
    for p in "$LAUNCH_AGENTS_DIR"/${PLIST_PREFIX}.*.plist; do
        [[ -f "$p" ]] || continue
        launchctl unload "$p" 2>/dev/null || true
        c=$((c + 1))
    done
    echo "$c"
}

setup_pmset_wake() {
    local earliest=""
    for t in "$@"; do
        local h
        h=$(echo "$t" | cut -d: -f1 | sed 's/^0*//')
        [[ -z "$h" ]] && h=0
        if ((h >= 0 && h <= 6)); then
            [[ -z "$earliest" || "$t" < "$earliest" ]] && earliest="$t"
        fi
    done

    [[ -z "$earliest" ]] && return 0

    local wh wm
    wh=$(echo "$earliest" | cut -d: -f1 | sed 's/^0*//')
    wm=$(echo "$earliest" | cut -d: -f2 | sed 's/^0*//')
    [[ -z "$wh" ]] && wh=0; [[ -z "$wm" ]] && wm=0
    wm=$((wm - 5))
    if ((wm < 0)); then
        wm=$((wm + 60)); wh=$((wh - 1))
        ((wh < 0)) && wh=23
    fi

    local wake_time
    wake_time=$(printf "%02d:%02d:00" "$wh" "$wm")
    info "Nighttime trigger ($earliest). Setting pmset wake at $wake_time"
    info "Requires sudo..."
    if sudo pmset repeat wakeorpoweron MTWRFSU "$wake_time"; then
        success "pmset wake set at $wake_time"
    else
        warn "Failed to set pmset wake"
    fi
}

# ── Commands ────────────────────────────────────────────────────────

cmd_setup() {
    echo ""
    echo -e "  ${BOLD}=== Claude Pulse Setup ===${NC}"
    echo ""

    # Auto-detect Claude CLI
    local claude_path="$HOME/.local/bin/claude"
    [[ -x "$claude_path" ]] || claude_path=$(command -v claude 2>/dev/null || true)
    if [[ -z "$claude_path" || ! -x "$claude_path" ]]; then
        error "Claude CLI not found. Install Claude Code first."
        exit 1
    fi
    local ver
    ver=$("$claude_path" --version 2>&1 | head -1) || true
    success "Found Claude CLI: $ver at $claude_path"

    # Migrate config if needed
    migrate_config_if_needed

    # Load existing triggers from config (v2 format)
    local triggers_json="[]"
    local ot_json="[]"

    if [[ -f "$CONFIG_FILE" ]]; then
        local _loaded
        _loaded=$(python3 << 'PYEOF'
import json, os
cfg = os.path.expanduser("~/.claude-pulse/config.json")
with open(cfg) as f: d = json.load(f)
print(json.dumps(d.get("recurring_triggers", [])))
print(json.dumps(d.get("onetime_triggers", [])))
PYEOF
        ) || true
        if [[ -n "$_loaded" ]]; then
            triggers_json=$(echo "$_loaded" | head -1)
            ot_json=$(echo "$_loaded" | tail -1)
            local _count
            _count=$(RECURRING="$triggers_json" ONETIME="$ot_json" python3 -c "
import json, os
r = json.loads(os.environ['RECURRING'])
o = json.loads(os.environ['ONETIME'])
print(len(r) + len(o))
") || true
            if [[ "$_count" -gt 0 ]] 2>/dev/null; then
                info "Loaded existing triggers from config"
            fi
        fi
    fi

    while true; do
        # Display configured triggers with per-task detail
        local _display
        _display=$(RECURRING="$triggers_json" ONETIME="$ot_json" python3 -c "
import json, os
r = json.loads(os.environ['RECURRING'])
o = json.loads(os.environ['ONETIME'])
if not r and not o:
    exit(0)

from datetime import date, datetime
today = date.today().isoformat()
now_hhmm = datetime.now().strftime('%H:%M')
GRN = '\033[32m'; BLU = '\033[34m'; RST2 = '\033[0m'

lines = []
lines.append('\033[0;34mConfigured triggers:\033[0m')
for tr in r:
    t = tr['time']
    tasks = tr.get('tasks', [{'mode': 'pulse'}])
    if t < now_hhmm:
        lines.append(f'  {BLU}Daily {t}:{RST2}')
    else:
        lines.append(f'  Daily {t}:')
    for task in tasks:
        if task['mode'] == 'pulse':
            lines.append(f'    - pulse')
        elif task['mode'] == 'prompt':
            p = task['prompt']
            if len(p) > 50: p = p[:50] + '...'
            mt = task.get('max_turns', 5)
            wd = task.get('work_directory', '')
            line = f'    - prompt: \"{p}\" ({mt} turns)'
            if wd: line += f' [{wd}]'
            lines.append(line)
for tr in o:
    d = tr['date']
    t = tr['time']
    tasks = tr.get('tasks', [{'mode': 'pulse'}])
    if d == today:
        dc = GRN
    elif d < today:
        dc = BLU
    else:
        dc = ''
    if dc:
        lines.append(f'  {dc}One-time {d} {t}:{RST2}')
    else:
        lines.append(f'  One-time {d} {t}:')
    for task in tasks:
        if task['mode'] == 'pulse':
            lines.append(f'    - pulse')
        elif task['mode'] == 'prompt':
            p = task['prompt']
            if len(p) > 50: p = p[:50] + '...'
            mt = task.get('max_turns', 5)
            wd = task.get('work_directory', '')
            line = f'    - prompt: \"{p}\" ({mt} turns)'
            if wd: line += f' [{wd}]'
            lines.append(line)

# Strip ANSI, count CJK as double-width for terminal alignment
import re, unicodedata
def visible_len(s):
    s = re.sub(r'\033\[[0-9;]*m', '', s)
    return sum(2 if unicodedata.east_asian_width(c) in ('W', 'F') else 1 for c in s)

w = max(visible_len(l) for l in lines) + 2
DIM = '\033[2m'
RST = '\033[0m'
print()
print(f'  {DIM}┌{\"─\" * (w + 2)}┐{RST}')
for l in lines:
    pad = w - visible_len(l)
    print(f'  {DIM}│{RST} {l}{\" \" * pad} {DIM}│{RST}')
print(f'  {DIM}└{\"─\" * (w + 2)}┘{RST}')
" 2>/dev/null) || true
        [[ -n "$_display" ]] && echo "$_display"

        ui_menu "What would you like to do?" \
            "Add recurring daily triggers" \
            "Add one-time trigger (specific date)" \
            "Clear all triggers" \
            "Apply and finish"

        case $UI_MENU_RESULT in
            -1) # ESC/q — same as Apply
                break
                ;;
            0)  # Recurring
                # Get existing recurring times for pre-selection
                local -a _existing_times=()
                local _etimes
                _etimes=$(echo "$triggers_json" | python3 -c "
import json, sys
for t in json.load(sys.stdin):
    print(t['time'])
" 2>/dev/null) || true
                if [[ -n "$_etimes" ]]; then
                    while IFS= read -r _t; do
                        [[ -n "$_t" ]] && _existing_times+=("$_t")
                    done <<< "$_etimes"
                fi

                if ((${#_existing_times[@]} > 0)); then
                    ui_time_grid "multi" "" "${_existing_times[@]}"
                else
                    ui_time_grid "multi" ""
                fi

                if [[ -n "$UI_GRID_RESULT" ]]; then
                    local -a new_times=($UI_GRID_RESULT)
                    local new_triggers_json="[]"

                    for nt in "${new_times[@]}"; do
                        # Check if this time existed before — preserve its tasks
                        local _existing_tasks
                        _existing_tasks=$(TRIGGERS="$triggers_json" TIME="$nt" python3 -c "
import json, os
triggers = json.loads(os.environ['TRIGGERS'])
t = os.environ['TIME']
for tr in triggers:
    if tr['time'] == t:
        print(json.dumps(tr['tasks']))
        break
" 2>/dev/null) || true

                        if [[ -n "$_existing_tasks" ]]; then
                            new_triggers_json=$(TRIGGERS="$new_triggers_json" TIME="$nt" TASKS="$_existing_tasks" python3 -c "
import json, os
triggers = json.loads(os.environ['TRIGGERS'])
triggers.append({'time': os.environ['TIME'], 'tasks': json.loads(os.environ['TASKS'])})
print(json.dumps(triggers))
")
                        else
                            # New time — configure tasks
                            ui_configure_tasks "$nt"
                            new_triggers_json=$(TRIGGERS="$new_triggers_json" TIME="$nt" TASKS="$UI_TASKS_RESULT" python3 -c "
import json, os
triggers = json.loads(os.environ['TRIGGERS'])
triggers.append({'time': os.environ['TIME'], 'tasks': json.loads(os.environ['TASKS'])})
print(json.dumps(triggers))
")
                        fi
                    done
                    triggers_json="$new_triggers_json"
                    success "Daily triggers updated"
                fi
                ;;
            1)  # One-time
                ui_date_selector
                if [[ -n "$UI_DATE_RESULT" ]]; then
                    local chosen_date="$UI_DATE_RESULT"
                    ui_time_grid "single" "$chosen_date"
                    if [[ -n "$UI_GRID_RESULT" ]]; then
                        local chosen_time="$UI_GRID_RESULT"
                        ui_configure_tasks "$chosen_time"
                        ot_json=$(OT="$ot_json" DATE="$chosen_date" TIME="$chosen_time" TASKS="$UI_TASKS_RESULT" python3 -c "
import json, os
ot = json.loads(os.environ['OT'])
ot.append({'date': os.environ['DATE'], 'time': os.environ['TIME'], 'tasks': json.loads(os.environ['TASKS'])})
print(json.dumps(ot))
")
                        success "Added: $chosen_date $chosen_time"
                    fi
                fi
                ;;
            2)  # Clear
                triggers_json="[]"
                ot_json="[]"
                success "All triggers cleared"
                ;;
            3)  # Apply
                break
                ;;
        esac
    done

    # Check if any triggers configured
    local _total
    _total=$(RECURRING="$triggers_json" ONETIME="$ot_json" python3 -c "
import json, os
r = json.loads(os.environ['RECURRING'])
o = json.loads(os.environ['ONETIME'])
print(len(r) + len(o))
") || true
    if [[ "$_total" == "0" ]]; then
        warn "No triggers configured."
        exit 0
    fi

    # Create directories
    mkdir -p "$CONFIG_DIR" "$LOG_DIR" "$LAUNCH_AGENTS_DIR"

    # Write config (v2)
    CLAUDE_PATH_VAL="$claude_path" HOME_DIR="$HOME" RECURRING="$triggers_json" ONETIME="$ot_json" python3 -c "
import json, os
config = {
    'config_version': 2,
    'claude_path': os.environ['CLAUDE_PATH_VAL'],
    'work_directory': os.environ['HOME_DIR'],
    'enabled': True,
    'recurring_triggers': json.loads(os.environ['RECURRING']),
    'onetime_triggers': json.loads(os.environ['ONETIME'])
}
cfg = os.path.expanduser('~/.claude-pulse/config.json')
with open(cfg, 'w') as f:
    json.dump(config, f, indent=2)
    f.write('\n')
"
    success "Config saved"

    # Generate trigger script
    generate_trigger_script
    success "Trigger script ready"

    # Remove old plists, generate new
    unload_existing_plists

    local -a plist_files=()

    # Recurring plists
    local _rec_times
    _rec_times=$(echo "$triggers_json" | python3 -c "
import json, sys
for tr in json.load(sys.stdin):
    print(tr['time'])
" 2>/dev/null) || true
    if [[ -n "$_rec_times" ]]; then
        while IFS= read -r t; do
            [[ -n "$t" ]] && plist_files+=("$(generate_recurring_plist "$t" "$claude_path")")
        done <<< "$_rec_times"
    fi

    # One-time plists
    local _ot_info
    _ot_info=$(echo "$ot_json" | python3 -c "
import json, sys
for tr in json.load(sys.stdin):
    print(tr['date'] + ' ' + tr['time'])
" 2>/dev/null) || true
    if [[ -n "$_ot_info" ]]; then
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            local d="${line%% *}" t="${line##* }"
            plist_files+=("$(generate_onetime_plist "$d" "$t" "$claude_path")")
        done <<< "$_ot_info"
    fi

    # pmset for nighttime triggers
    local -a all_times=()
    if [[ -n "$_rec_times" ]]; then
        while IFS= read -r t; do
            [[ -n "$t" ]] && all_times+=("$t")
        done <<< "$_rec_times"
    fi
    if [[ -n "$_ot_info" ]]; then
        while IFS= read -r line; do
            [[ -n "$line" ]] && all_times+=("${line##* }")
        done <<< "$_ot_info"
    fi
    ((${#all_times[@]} > 0)) && setup_pmset_wake "${all_times[@]}" || true

    # Load plists
    local loaded
    loaded=$(load_all_plists)
    success "Loaded $loaded agent(s)"

    # Verify
    echo ""
    bash -n "$TRIGGER_SCRIPT" 2>/dev/null && success "trigger.sh syntax OK" || warn "trigger.sh syntax error"
    if ((${#plist_files[@]} > 0)); then
        for pf in "${plist_files[@]}"; do
            plutil -lint "$pf" > /dev/null 2>&1 && \
                success "$(basename "$pf") valid" || \
                warn "$(basename "$pf") invalid"
        done
    fi

    echo ""
    success "Setup complete! Claude Pulse is active."
    echo ""
    echo "  claude-pulse status  — check state"
    echo "  claude-pulse logs    — view logs"
    echo ""
}

cmd_status() {
    echo ""
    echo -e "  ${BOLD}=== Claude Pulse Status ===${NC}"
    echo ""

    if [[ ! -f "$CONFIG_FILE" ]]; then
        warn "Not configured. Run 'claude-pulse setup'"
        exit 0
    fi

    migrate_config_if_needed

    local enabled claude_path
    enabled=$(json_get "$CONFIG_FILE" "enabled")
    claude_path=$(json_get "$CONFIG_FILE" "claude_path")

    if [[ "$enabled" == "True" ]]; then
        echo -e "  Status:    ${GREEN}ENABLED${NC}"
    else
        echo -e "  Status:    ${RED}DISABLED${NC}"
    fi
    echo "  Claude:    $claude_path"

    # Display triggers with tasks
    local _trigger_display
    _trigger_display=$(python3 -c "
import json
d = json.load(open('$CONFIG_FILE'))
for tr in d.get('recurring_triggers', []):
    t = tr['time']
    tasks = tr.get('tasks', [{'mode': 'pulse'}])
    parts = []
    for task in tasks:
        if task['mode'] == 'pulse':
            parts.append('pulse')
        elif task['mode'] == 'prompt':
            p = task['prompt']
            if len(p) > 40: p = p[:40] + '...'
            parts.append(f'prompt: \"{p}\" ({task.get(\"max_turns\", 5)}t)')
    print(f'  Daily:     {t}  [{\"  |  \".join(parts)}]')
for tr in d.get('onetime_triggers', []):
    tasks = tr.get('tasks', [{'mode': 'pulse'}])
    parts = []
    for task in tasks:
        if task['mode'] == 'pulse':
            parts.append('pulse')
        elif task['mode'] == 'prompt':
            p = task['prompt']
            if len(p) > 40: p = p[:40] + '...'
            parts.append(f'prompt: \"{p}\" ({task.get(\"max_turns\", 5)}t)')
    print(f'  One-time:  {tr[\"date\"]} {tr[\"time\"]}  [{\"  |  \".join(parts)}]')
" 2>/dev/null) || true
    [[ -n "$_trigger_display" ]] && echo "$_trigger_display"

    # Launch agents
    echo ""
    echo "  Launch Agents:"
    local has=false
    for p in "$LAUNCH_AGENTS_DIR"/${PLIST_PREFIX}.*.plist; do
        [[ -f "$p" ]] || continue
        has=true
        local label
        label=$(basename "$p" .plist)
        if launchctl list "$label" > /dev/null 2>&1; then
            echo -e "    ${GREEN}LOADED${NC}  $label"
        else
            echo -e "    ${YELLOW}IDLE${NC}    $label"
        fi
    done
    [[ "$has" == false ]] && echo "    (none)"

    # pmset
    echo ""
    echo "  pmset wake schedule:"
    local pmset_info
    pmset_info=$(pmset -g sched 2>/dev/null | grep -i "wake" || true)
    echo "    ${pmset_info:-(none)}"

    # Recent logs
    echo ""
    echo "  Recent logs:"
    local latest
    latest=$(ls -t "$LOG_DIR"/pulse-*.log 2>/dev/null | head -1)
    if [[ -n "$latest" ]]; then
        tail -5 "$latest" | while IFS= read -r line; do echo "    $line"; done
    else
        echo "    (none)"
    fi
    echo ""
}

cmd_start() {
    [[ -f "$CONFIG_FILE" ]] || { error "Run 'claude-pulse setup' first"; exit 1; }

    migrate_config_if_needed
    json_set_bool "$CONFIG_FILE" "enabled" "True"

    local loaded
    loaded=$(load_all_plists)
    ((loaded == 0)) && { warn "No agents. Run setup."; exit 1; }

    success "Started ($loaded agents)"

    # Re-apply pmset
    local -a arr=()
    local _times
    _times=$(python3 -c "
import json
d = json.load(open('$CONFIG_FILE'))
for tr in d.get('recurring_triggers', []):
    print(tr['time'])
for tr in d.get('onetime_triggers', []):
    print(tr['time'])
" 2>/dev/null) || true
    if [[ -n "$_times" ]]; then
        while IFS= read -r t; do
            [[ -n "$t" ]] && arr+=("$t")
        done <<< "$_times"
    fi
    ((${#arr[@]} > 0)) && setup_pmset_wake "${arr[@]}" || true
}

cmd_stop() {
    [[ -f "$CONFIG_FILE" ]] || { error "Run 'claude-pulse setup' first"; exit 1; }

    migrate_config_if_needed
    json_set_bool "$CONFIG_FILE" "enabled" "False"

    local unloaded
    unloaded=$(unload_all_plists)

    success "Stopped ($unloaded agents)"
    warn "pmset wake still active. Cancel: sudo pmset repeat cancel"
}

cmd_logs() {
    local num=20 date_filter=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --today) date_filter=$(date +%Y-%m-%d); shift ;;
            --lines|-n) num="$2"; shift 2 ;;
            [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]) date_filter="$1"; shift ;;
            *) shift ;;
        esac
    done

    if [[ -n "$date_filter" ]]; then
        local f="$LOG_DIR/pulse-${date_filter}.log"
        [[ -f "$f" ]] && cat "$f" || info "No logs for $date_filter"
    else
        echo "=== Recent logs (last $num) ==="
        echo ""
        if ls "$LOG_DIR"/pulse-*.log > /dev/null 2>&1; then
            cat "$LOG_DIR"/pulse-*.log | sort | tail -"$num"
        else
            info "No logs yet"
        fi
    fi
}

cmd_help() {
    cat << 'EOF'
Claude Pulse - Auto-trigger Claude Code for token quota refresh & task execution

Usage: claude-pulse <command> [options]

Commands:
  setup     Interactive configuration (triggers + tasks)
  start     Enable triggers
  stop      Disable triggers
  status    Show state and configured tasks
  logs      Show trigger logs
  help      This message

Task modes (configured during setup):
  pulse     Minimal "pulse" to keep tokens fresh (default)
  prompt    Custom prompt — Claude executes a real task

Multiple tasks per trigger run in parallel.

Log options:
  --today         Today's logs
  -n N            Last N entries (default 20)
  YYYY-MM-DD      Logs for date
EOF
}

# ── Main ────────────────────────────────────────────────────────────

case "${1:-help}" in
    setup)  cmd_setup ;;
    start)  cmd_start ;;
    stop)   cmd_stop ;;
    status) cmd_status ;;
    logs)   shift; cmd_logs "$@" ;;
    help|-h|--help) cmd_help ;;
    *)      error "Unknown: $1"; cmd_help; exit 1 ;;
esac
